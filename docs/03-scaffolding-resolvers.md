## Scaffolding Resolvers

> **IMPORTANT**: Scaffolded resolvers are typically generated into a _temporary_ directory and manually copied over into your actual source files. After the generated resolver skeletons have been copied over, the generated files can be deleted.

This feature increases your productivity by generating the boilerplate resolver skeletons for those fields that are not [default resolvers](#default-resolvers). A great example for this are the resolvers for your [_root types_](https://www.prisma.io/blog/graphql-server-basics-the-schema-ac5e2950214e/): `Query`, `Mutation` and `Subscription`.

For fields on these types, the resolver implementation needs to call out to some data source (e.g. a database, a REST API or a Prisma service) and therefore can not be automatically generated by `graphqlgen`. However, `graphqlgen` is able to reduce the amount of boilerplate you need to write by generating resolver "skeletons".

Consider the following `Query` type:

```graphql
type Query {
  user(id: ID!): User
}
```

The resolver skeleton for the `user` field will look similar to this:

```ts
export const Query: QueryResolvers.Type = {
  user: (parent, args) => null,
}
```

With that boilerplate in place, all that's left to do for the developer is implement fetching the requested `User` object from some data source (guided by the generated typings for resolver arguments and return values).

The relevant properties from `graphqlgen.yml` for the Scaffolding feature are:

- `language` (required)
- `schema` (required)
- `models` (required)
- `context` (optional)
- `output` (required)
- `resolver-scaffolding` (required)

### Example

#### Setup

Assume you have the following minimal setup with three files:

**`./src/schema.graphql`**

```graphql
type Query {
  user(id: ID!): User
}

type Mutation {
  createUser(name: String): User!
}

type User {
  id: ID!
  name: String
}
```

**`./src/models.ts`**

```ts
export interface User {
  id: string
  name: string | null
  password: string
}
```

**`./graphqlgen.yml`**

```yml
language: typescript
schema: ./src/schema.graphql
models:
  files:
    - ./src/models.ts
output: ./src/generated/graphqlgen.ts
resolver-scaffolding:
  output: ./src/tmp/
  layout: file-per-type
```

#### Generated code

After running `$ graphqlgen` in your terminal, the following code will be generated into **`./src/tmp/`**:

**`./tmp/User.ts`**

```ts
import { UserResolvers } from '../generated/graphqlgen'

export const User: UserResolvers.Type = {
  ...UserResolvers.defaultResolvers,
}
```

**`./tmp/Query.ts`**

```ts
import { QueryResolvers } from '../generated/graphqlgen'

export const Query: QueryResolvers.Type = {
  ...QueryResolvers.defaultResolvers,
  user: (parent, args) => null,
}
```

**`./tmp/Mutation.ts`**

```ts
import { MutationResolvers } from '../generated/graphqlgen'

export const Mutation: MutationResolvers.Type = {
  ...MutationResolvers.defaultResolvers,
  createUser: (parent, args) => {
    throw new Error('Resolver not implemented')
  },
}
```

**`./tmp/index.ts`**

```ts
import { Resolvers } from '../generated/graphqlgen'

import { Query } from './Query'
import { Mutation } from './Mutation'
import { User } from './User'

export const resolvers: Resolvers = {
  Query,
  Mutation,
  User,
}
```

Note the following:

- The paths in the `import` statements will likely need to be adjusted depending on your file structure.
